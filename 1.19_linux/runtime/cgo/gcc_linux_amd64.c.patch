//--from
#include <stdlib.h>
//--to
#include <stdlib.h>
#include <unistd.h> // for usleep
//--append
// Define C functions and system calls for Cgo.

typedef unsigned int gid_t;

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset) {
  abort();
  return NULL;
}

int munmap(void *addr, size_t length) {
  abort();
  return 0;
}

int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset) {
  // Do nothing.
  return 0;
}

int setegid(gid_t gid) {
  // Do nothing.
  return 0;
}

int seteuid(uid_t gid) {
  // Do nothing.
  return 0;
}

int setgid(gid_t gid) {
  // Do nothing.
  return 0;
}

int setgroups(size_t size, const gid_t *list) {
  // Do nothing.
  return 0;
}

int setregid(gid_t rgid, gid_t egid) {
  // Do nothing.
  return 0;
}

int setreuid(uid_t ruid, uid_t euid) {
  // Do nothing.
  return 0;
}

int setresgid(gid_t rgid, gid_t egid, gid_t sgid) {
  // Do nothing.
  return 0;
}

int setresuid(uid_t ruid, uid_t euid, uid_t suid) {
  // Do nothing.
  return 0;
}

int setuid(uid_t gid) {
  // Do nothing.
  return 0;
}

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
  // Do nothing.
  return 0;
}

int sigaddset(sigset_t *set, int signum) {
  // Do nothing.
  return 0;
}

int sigemptyset(sigset_t *set) {
  // Do nothing.
  return 0;
}

int sigfillset(sigset_t *set) {
  // Do nothing.
  return 0;
}

int sigismember(const sigset_t *set, int signum) {
  // Do nothing.
  return 0;
}

static const int kFDOffset = 100;

typedef struct {
  const void* content;
  size_t      content_size;
  size_t      current;
  int32_t     fd;
} pseudo_file;

// TODO: Do we need to protect this by mutex?
static pseudo_file pseudo_files[100];

static pthread_mutex_t* pseudo_file_mutex() {
  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
  return &mutex;
}

static int32_t open_pseudo_file(const void* content, size_t content_size) {
  pthread_mutex_lock(pseudo_file_mutex());

  int index = 0;
  int found = 0;
  for (int i = 0; i < sizeof(pseudo_files) / sizeof(pseudo_file); i++) {
    if (pseudo_files[i].fd == 0) {
      index = i;
      found = 1;
      break;
    }
  }
  if (!found) {
    // Too many pseudo files are opened.
    pthread_mutex_unlock(pseudo_file_mutex());
    return -1;
  }
  int32_t fd = index + kFDOffset;
  pseudo_files[index].content = content;
  pseudo_files[index].content_size = content_size;
  pseudo_files[index].current = 0;
  pseudo_files[index].fd = fd;

  pthread_mutex_unlock(pseudo_file_mutex());
  return fd;
}

static size_t read_pseudo_file(int32_t fd, void *p, int32_t n) {
  pthread_mutex_lock(pseudo_file_mutex());

  int32_t index = fd - kFDOffset;
  pseudo_file *file = &pseudo_files[index];
  size_t rest = file->content_size - file->current;
  if (rest < n) {
    n = rest;
  }
  memcpy(p, file->content + file->current, n);
  pseudo_files[index].current += n;

  pthread_mutex_unlock(pseudo_file_mutex());
  return n;
}

static void close_pseudo_file(int32_t fd) {
  pthread_mutex_lock(pseudo_file_mutex());

  int32_t index = fd - kFDOffset;
  pseudo_files[index].content = NULL;
  pseudo_files[index].content_size = 0;
  pseudo_files[index].current = 0;
  pseudo_files[index].fd = 0;

  pthread_mutex_unlock(pseudo_file_mutex());
}

#ifndef user_futex
static const int kPseudoFutexWait = 0;
static const int kPseudoFutexWake = 1;

static void pseudo_futex(uint32_t *uaddr, int mode, uint32_t val, const struct timespec *reltime) {
  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
  static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

  struct timespec abstime;
  if (reltime) {
    // We are not sure CLOCK_REALTIME is correct or not here.
    // However, this time limit is actually not used as the condition variable is shared by
    // all the threads. Before the time limit reaches, the thread wakes up in 99.9999...% cases.
    clock_gettime(CLOCK_REALTIME, &abstime);
    abstime.tv_sec += reltime->tv_sec;
    abstime.tv_nsec += reltime->tv_nsec;
    if (1000000000 <= abstime.tv_nsec) {
      abstime.tv_sec += 1;
      abstime.tv_nsec -= 1000000000;
    }
  }

  int ret = pthread_mutex_lock(&mutex);
  if (ret) {
    fprintf(stderr, "pthread_mutex_lock failed: %d\n", ret);
    abort();
  }

  switch (mode) {
  case kPseudoFutexWait:
    if (reltime) {
      uint32_t v = 0;
      __atomic_load(uaddr, &v, __ATOMIC_RELAXED);
      if (v == val) {
        int ret = pthread_cond_timedwait(&cond, &mutex, &abstime);
        if (ret && ret != ETIMEDOUT) {
          fprintf(stderr, "pthread_cond_timedwait failed: %d\n", ret);
          abort();
        }
      }
    } else {
      uint32_t v = 0;
      __atomic_load(uaddr, &v, __ATOMIC_RELAXED);
      if (v == val) {
        int ret = pthread_cond_wait(&cond, &mutex);
        if (ret) {
          fprintf(stderr, "pthread_cond_wait failed: %d\n", ret);
          abort();
        }
      }
    }
    break;
  case kPseudoFutexWake:
    if (val != 1) {
      fprintf(stderr, "val for waking must be 1 but %d\n", val);
      abort();
    }
    // TODO: broadcasting is not efficient. Use a mutex for each uaddr.
    int ret = pthread_cond_broadcast(&cond);
    if (ret) {
      fprintf(stderr, "pthread_cond_broadcast failed: %d\n", ret);
      abort();
    }
    break;
  }

  ret = pthread_mutex_unlock(&mutex);
  if (ret) {
    fprintf(stderr, "pthread_mutex_unlock failed: %d\n", ret);
    abort();
  }
}
#endif

int32_t c_closefd(int32_t fd) {
  if (fd >= kFDOffset) {
    close_pseudo_file(fd);
    return 0;
  }
  fprintf(stderr, "syscall close(%d) is not implemented\n", fd);
  return 0;
}

int32_t c_futex(uint32_t *uaddr, int32_t futex_op, uint32_t val,
                const struct timespec *timeout,
                uint32_t *uaddr2, uint32_t val3) {
#ifdef user_futex
  return user_futex(uaddr, futex_op, val, timeout, uaddr2, val3);
#else
  enum {
    kFutexWaitPrivate = 128,
    kFutexWakePrivate = 129,
  };

  switch (futex_op) {
  case kFutexWaitPrivate:
    pseudo_futex(uaddr, kPseudoFutexWait, val, timeout);
    break;
  case kFutexWakePrivate:
    pseudo_futex(uaddr, kPseudoFutexWake, val, NULL);
    break;
  }

  // This function should return the number of awaken threads, but now it is impossible.
  // Just return 0.
  return 0;
#endif
}

uint32_t c_gettid() {
  uint64_t tid64 = (uint64_t)(pthread_self());
  uint32_t tid = (uint32_t)(tid64 >> 32) ^ (uint32_t)(tid64);
  return tid;
}

uintptr_t c_calloc(size_t num, size_t size) {
  void *ptr = calloc(num, size);
  return (uintptr_t)ptr;
}

int64_t c_nanotime1() {
  struct timespec tp;
  clock_gettime(CLOCK_MONOTONIC, &tp);
  return (int64_t)(tp.tv_sec) * 1000000000ll + (int64_t)tp.tv_nsec;
}

int32_t c_open(char *name, int32_t mode, int32_t perm) {
  const static int kENOENT = 0x2;
  int ret = kENOENT;
  if (strcmp(name, "/proc/self/auxv") == 0) {
    static const char auxv[] =
      "\x06\x00\x00\x00\x00\x00\x00\x00"  // _AT_PAGESZ tag (6)
      "\x00\x10\x00\x00\x00\x00\x00\x00"  // 4096 bytes per page
      "\x00\x00\x00\x00\x00\x00\x00\x00"  // Dummy bytes
      "\x00\x00\x00\x00\x00\x00\x00\x00"; // Dummy bytes
    ret = open_pseudo_file(auxv, sizeof(auxv) / sizeof(char));
  } else if (strcmp(name, "/sys/kernel/mm/transparent_hugepage/hpage_pmd_size") == 0) {
    static const char hpage_pmd_size[] =
      "\x30\x5c"; // '0', '\n'
    ret = open_pseudo_file(hpage_pmd_size, sizeof(hpage_pmd_size) / sizeof(char));
  } else {
    fprintf(stderr, "syscall open(\"%s\", %d, %d) is not implemented\n", name, mode, perm);
  }
  return ret;
}

int32_t c_osyield() {
  return sched_yield();
}

int32_t c_read(int32_t fd, void *p, int32_t n) {
  if (fd >= kFDOffset) {
    return read_pseudo_file(fd, p, n);
  }
  fprintf(stderr, "syscall read(%d, %p, %d) is not implemented\n", fd, p, n);
  const static int kEBADF = 0x9;
  return kEBADF;
}

void c_usleep(useconds_t usec) {
  usleep(usec);
}

void c_walltime1(int64_t* sec, int32_t* nsec) {
  struct timespec tp;
  clock_gettime(CLOCK_REALTIME, &tp);
  *sec = tp.tv_sec;
  *nsec = tp.tv_nsec;
}

int32_t c_write(uintptr_t fd, void *p, int32_t n) {
  static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
  int32_t ret = 0;
  pthread_mutex_lock(&m);
  switch (fd) {
  case 1:
    ret = fwrite(p, 1, n, stdout);
    fflush(stdout);
    break;
  case 2:
    ret = fwrite(p, 1, n, stderr);
    fflush(stderr);
    break;
  default:
    fprintf(stderr, "syscall write(%lu, %p, %d) is not implemented\n", fd, p, n);
    break;
  }
  pthread_mutex_unlock(&m);
  return ret;
}

void c_exit(int32_t code) {
  exit(code);
}

int c_sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask) {
  // FIXME: do something here
  return 0;
}
